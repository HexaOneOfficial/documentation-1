{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wiki DEVSE Ce guide est disponible \u00e0 l'adresse developpement-systeme-exploitation.github.io/documentation . Documentation Ce r\u00e9pertoire GitHub a \u00e9t\u00e9 cr\u00e9\u00e9 pour fournir une documentation sur le d\u00e9veloppement de syst\u00e8mes d'exploitation en Fran\u00e7ais. N'h\u00e9sitez pas \u00e0 contribuer \u00e0 la documentation, rajouter des exemples, etc ! Nous ne sommes pas affili\u00e9s au site Internet OSDEV, mais au serveur Discord Fran\u00e7ais DEVSE . l' arborescence x86_64 Cette section est d\u00e9di\u00e9e au support 64 bit pour l'architecture x86. tutoriels premiers pas chapitre 0 - introduction chapitre 1 - Hello world chapitre 2 - Segmentation chapitre 3 - Interruption chapitre 4 - M\u00e9moire chapitre 5 - Pagination chapitre 6 - Multitache chapitre 7 - Tache Utilisateur chapitre 8 - Epilogue smp SMP VERROU structures GDT IDT p\u00e9riph\u00e9riques APIC COM LAPIC MADT PIC PIT Interruptions code d'erreur autre Awesome (devse) Licence Cette \u0153uvre est mise \u00e0 disposition selon les termes de la Licence Creative Commons Attribution 2.0 France .","title":"Wiki DEVSE"},{"location":"#wiki-devse","text":"Ce guide est disponible \u00e0 l'adresse developpement-systeme-exploitation.github.io/documentation .","title":"Wiki DEVSE"},{"location":"#documentation","text":"Ce r\u00e9pertoire GitHub a \u00e9t\u00e9 cr\u00e9\u00e9 pour fournir une documentation sur le d\u00e9veloppement de syst\u00e8mes d'exploitation en Fran\u00e7ais. N'h\u00e9sitez pas \u00e0 contribuer \u00e0 la documentation, rajouter des exemples, etc ! Nous ne sommes pas affili\u00e9s au site Internet OSDEV, mais au serveur Discord Fran\u00e7ais DEVSE .","title":"Documentation"},{"location":"#l-arborescence","text":"","title":"l' arborescence"},{"location":"#x86_64","text":"Cette section est d\u00e9di\u00e9e au support 64 bit pour l'architecture x86.","title":"x86_64"},{"location":"#tutoriels","text":"premiers pas chapitre 0 - introduction chapitre 1 - Hello world chapitre 2 - Segmentation chapitre 3 - Interruption chapitre 4 - M\u00e9moire chapitre 5 - Pagination chapitre 6 - Multitache chapitre 7 - Tache Utilisateur chapitre 8 - Epilogue smp SMP VERROU","title":"tutoriels"},{"location":"#structures","text":"GDT IDT","title":"structures"},{"location":"#peripheriques","text":"APIC COM LAPIC MADT PIC PIT","title":"p\u00e9riph\u00e9riques"},{"location":"#interruptions","text":"code d'erreur","title":"Interruptions"},{"location":"#autre","text":"Awesome (devse)","title":"autre"},{"location":"#licence","text":"Cette \u0153uvre est mise \u00e0 disposition selon les termes de la Licence Creative Commons Attribution 2.0 France .","title":"Licence"},{"location":"CONTRIBUER/","text":"Contribuer au wiki Avant toute contribution, la lecture de ce domument est obligatoire. Veuillez employer un fran\u00e7ais correct. Notre langue n'est pas des plus simples, mais son bon emploi standard nous permet de nous comprendre mutuellement de fa\u00e7on claire, d'autant plus dans un domaine aussi sp\u00e9cifique que le d\u00e9veloppement de syst\u00e8mes d'exploitation. Les langages de programmation principalement utilis\u00e9s dans les exemples sont le C, le C++ et l'assembleur x86, avec une syntaxe Intel. En effet, ce sont des langages couramment utilis\u00e9 lorsque l'on programme un noyau, un OS, ou un pilote. Veuillez produire votre propre contenu. Les copier-collers sont contre-productifs pour vous. C'est en r\u00e9fl\u00e9chissant par soi-m\u00eame et en interpr\u00e9tant soi-m\u00eame ce que l'on \u00e9volue. Nous \u00e9vitons d'utiliser les architectures en 32 bits car elles ne sont plus forc\u00e9ment d'actualit\u00e9. La structure suivante est de rigueur pour l'ensemble des documents : La partie \"haute\" du document regroupe le sommaire de l'article, ainsi que les liens qui permettent de s'y balader. Vous retrouverez ensuite, factuellement, une liste d\u00e9taill\u00e9e et argument\u00e9e des pr\u00e9r\u00e9quis pour la compr\u00e9hension d'un article, ou l'application d'un tutoriel. Le reste du document est constitu\u00e9 du sujet de l'article. Typiquement: introduction au sujet, explication, illustration par les exemples/m\u00e9taphores/comparaisons, conclusion et ressenti personnel. L'article doit imp\u00e9rativement donner acc\u00e8s aux ressources qui lui ont permis d'\u00eatre d\u00e9velopp\u00e9. Ces ressources peuvent \u00eatre d'autres articles v\u00e9rifi\u00e9s, des livres, des vid\u00e9os ou des topics dans des forums. Commits / Pull requests Vous devez suivre les r\u00e8gles suivantes pour la r\u00e9daction des noms de commits / pull requests. type de la modification: ce que vous avez fait / rajout\u00e9 Les types de modification peuvent \u00eatre : correction x64 arm misc (on y compte par exemple les ports COM, les syst\u00e8mes de fichiers ou tout autre chose qui ne rentre pas dans les cat\u00e9gories d'architecture) exemple (ajout d'exemple) autre (pour autre chose qui n'y entre pas) Il est recommand\u00e9 de ne pas faire plus d'un Commit par Pull Resquest. Marche \u00e0 suivre pour les exemples Suivez la structure des documents, pour que l'exemple en question soit coh\u00e9rent avec le reste de l'article. Appliquez-vous sur votre code (lisibilit\u00e9, commentaires, v\u00e9rification). M\u00eame si les langages majoritairement utilis\u00e9s sont le C, le C++ et l'assembleur x86 (voir la liste en haut de la page), il peut \u00eatre utile d'utiliser d'autres langages de programmation/sch\u00e9matiques qui permettraient d'interpr\u00e9ter clairement une information. MERCI AUX CONTRIBUTEURS SUIVANTS <3 busybox11 monax d0p1 fomys supercyp Daimyo","title":"Contribuer au wiki"},{"location":"CONTRIBUER/#contribuer-au-wiki","text":"","title":"Contribuer au wiki"},{"location":"CONTRIBUER/#avant-toute-contribution-la-lecture-de-ce-domument-est-obligatoire","text":"Veuillez employer un fran\u00e7ais correct. Notre langue n'est pas des plus simples, mais son bon emploi standard nous permet de nous comprendre mutuellement de fa\u00e7on claire, d'autant plus dans un domaine aussi sp\u00e9cifique que le d\u00e9veloppement de syst\u00e8mes d'exploitation. Les langages de programmation principalement utilis\u00e9s dans les exemples sont le C, le C++ et l'assembleur x86, avec une syntaxe Intel. En effet, ce sont des langages couramment utilis\u00e9 lorsque l'on programme un noyau, un OS, ou un pilote. Veuillez produire votre propre contenu. Les copier-collers sont contre-productifs pour vous. C'est en r\u00e9fl\u00e9chissant par soi-m\u00eame et en interpr\u00e9tant soi-m\u00eame ce que l'on \u00e9volue. Nous \u00e9vitons d'utiliser les architectures en 32 bits car elles ne sont plus forc\u00e9ment d'actualit\u00e9.","title":"Avant toute contribution, la lecture de ce domument est obligatoire."},{"location":"CONTRIBUER/#la-structure-suivante-est-de-rigueur-pour-lensemble-des-documents","text":"La partie \"haute\" du document regroupe le sommaire de l'article, ainsi que les liens qui permettent de s'y balader. Vous retrouverez ensuite, factuellement, une liste d\u00e9taill\u00e9e et argument\u00e9e des pr\u00e9r\u00e9quis pour la compr\u00e9hension d'un article, ou l'application d'un tutoriel. Le reste du document est constitu\u00e9 du sujet de l'article. Typiquement: introduction au sujet, explication, illustration par les exemples/m\u00e9taphores/comparaisons, conclusion et ressenti personnel. L'article doit imp\u00e9rativement donner acc\u00e8s aux ressources qui lui ont permis d'\u00eatre d\u00e9velopp\u00e9. Ces ressources peuvent \u00eatre d'autres articles v\u00e9rifi\u00e9s, des livres, des vid\u00e9os ou des topics dans des forums.","title":"La structure suivante est de rigueur pour l'ensemble des documents :"},{"location":"CONTRIBUER/#commits-pull-requests","text":"Vous devez suivre les r\u00e8gles suivantes pour la r\u00e9daction des noms de commits / pull requests.","title":"Commits / Pull requests"},{"location":"CONTRIBUER/#type-de-la-modification-ce-que-vous-avez-fait-rajoute","text":"Les types de modification peuvent \u00eatre : correction x64 arm misc (on y compte par exemple les ports COM, les syst\u00e8mes de fichiers ou tout autre chose qui ne rentre pas dans les cat\u00e9gories d'architecture) exemple (ajout d'exemple) autre (pour autre chose qui n'y entre pas) Il est recommand\u00e9 de ne pas faire plus d'un Commit par Pull Resquest.","title":"type de la modification: ce que vous avez fait / rajout\u00e9"},{"location":"CONTRIBUER/#marche-a-suivre-pour-les-exemples","text":"Suivez la structure des documents, pour que l'exemple en question soit coh\u00e9rent avec le reste de l'article. Appliquez-vous sur votre code (lisibilit\u00e9, commentaires, v\u00e9rification). M\u00eame si les langages majoritairement utilis\u00e9s sont le C, le C++ et l'assembleur x86 (voir la liste en haut de la page), il peut \u00eatre utile d'utiliser d'autres langages de programmation/sch\u00e9matiques qui permettraient d'interpr\u00e9ter clairement une information.","title":"Marche \u00e0 suivre pour les exemples"},{"location":"CONTRIBUER/#merci-aux-contributeurs-suivants-3","text":"busybox11 monax d0p1 fomys supercyp Daimyo","title":"MERCI AUX CONTRIBUTEURS SUIVANTS &lt;3"},{"location":"meta/template/","text":"Titre de l'article Introduction Ressources","title":"Titre de l'article"},{"location":"meta/template/#titre-de-larticle","text":"","title":"Titre de l'article"},{"location":"meta/template/#introduction","text":"","title":"Introduction"},{"location":"meta/template/#ressources","text":"","title":"Ressources"},{"location":"x86_64/interruption/CODE_DERREUR/","text":"Codes d'erreur d'interruption Toutes les interruptions entre 0 et 32 sont des interruptions d'erreur. Certains codes d'erreur peuvent \u00eatre corrig\u00e9s apr\u00e8s le retour de l'interruption. Cependant, d'autres ne peuvent pas l'\u00eatre. Code de l'interruption Nom Descriptions Contient un code d'erreur ? 0 Division par 0 Cette erreur est produite quand l'instruction DIV/IDIV est utilis\u00e9e avec un 0 non 1 Debug Cette erreur intentionnelle est g\u00e9n\u00e9ralement utilis\u00e9e pour d\u00e9boguer non 2 Interruption NMI L'interruption NMI est une interruption caus\u00e9e par des \u00e9l\u00e9ments externes comme la RAM non 3 Breakpoint Cette erreur intentionnelle est g\u00e9n\u00e9ralement utilis\u00e9e pour le d\u00e9bogage non 4 D\u00e9passement L'interruption 4 est caus\u00e9e lorsque l'instruction INTO est \u00e9x\u00e9cut\u00e9 alors que le bit 11 de RFLAGS est mis \u00e0 1. Note : l'erreur n'est pas possible en 64 bits car l'instruction INTO n'est pas disponible en mode long . non 5 D\u00e9passement de table L'interruption 5 est caus\u00e9e lorsque l'instruction BOUND est ex\u00e9cut\u00e9e quand op\u00e9rateur 1 n'est pas dans la taille de table d\u00e9finie dans l'op\u00e9rateur 2. Note : l'erreur n'est pas possible en 64 bits car l'instruction BOUND n'est pas disponible en mode long . non 6 Instruction non valide L'interruption 6 est caus\u00e9e lorsque : - On essaye d'acc\u00e9der \u00e0 un registre non existant - On essaye d'ex\u00e9cuter une instruction non disponible - UD est ex\u00e9cut\u00e9 non 7 Appareil non disponible L'interruption 7 est appel\u00e9e lorsqu'on essaye d'initialiser le FPU alors qu'il n'existe pas non 8 Faute Double La faute double est appel\u00e9e lorsqu'il y a une erreur pendant que l'interruption d'erreur est appel\u00e9e (une erreur dans une erreur) oui 9 Erreur de Segment de coprocesseur Cette erreur n'est plus utilis\u00e9e. non 10 TSS invalide L'interruption TSS invalide est ex\u00e9cut\u00e9e lorsque le s\u00e9lecteur de segment pour la TSS est invalide. Caus\u00e9e pendant un changement de t\u00e2che ou pendant l'acc\u00e8s de la TSS oui (code d'erreur de segment) 11 Segment non pr\u00e9sent L'interruption \"Segment non pr\u00e9sent\" est ex\u00e9cut\u00e9e lorsqu'on essaye de charger un segment qui a son bit pr\u00e9sent \u00e0 0 oui (code d'erreur de segment) 12 Segment de pile invalide L'interruption \"Segment de pile\" invalide est caus\u00e9e lorsque : - On charge un segment de pile qui n'est pas pr\u00e9sent - La v\u00e9rification de la limite de pile n'est pas possible - (64bit) On essaye de faire une op\u00e9ration qui fait une r\u00e9f\u00e9rence \u00e0 la m\u00e9moire en utilisant le pointeur de pile (RSP) qui contient une adresse m\u00e9moire non canonique - Le segment de pile n'est pas pr\u00e9sent pendant une op\u00e9ration qui fait r\u00e9f\u00e9rence au registre SS , (comme pop , push , iret ...) oui (code d'erreur de segment) 13 Faute g\u00e9n\u00e9rale de protection L'interruption n\u00b013 peut \u00eatre caus\u00e9e par beaucoup de raisons, comme : - L'\u00e9criture d'un 1 dans une zone du registre CR4 r\u00e9serv\u00e9e - L'utilisation une instruction SSE qui essaye d'acc\u00e9der une zone de la m\u00e9moire 128 bits qui n'est pas align\u00e9e en 16bit - Une pile de m\u00e9moire non align\u00e9e en 16bit [...]. Voir le manuel Intel pour plus d'informations (chap 3 6.15.13) oui (code d'erreur de segments) 14 Faute de page L'interruption n\u00b014 peut \u00eatre caus\u00e9e lorsque : - Il y a une erreur en relation avec le paging - On essaye d'acc\u00e9der \u00e0 une zone de la m\u00e9moire qui n'a pas de table pr\u00e9sente - On essaye de charger une table et que la zone ou on \u00e9x\u00e9cute le code n'est pas ex\u00e9cutable dans la page - Un probl\u00e8me d'autorisation est caus\u00e9 (ex: \u00e9crire dans une zone de la m\u00e9moire qui ne peut pas \u00eatre \u00e9crite) [...] Voir le manuel Intel pour plus d'informations (chap 3 6.15.14) oui (code d'erreur de page) 15 R\u00e9serv\u00e9 // non 16 Faute du FPU x87 L'interruption n\u00b016 est caus\u00e9e lorsqu'il y a une erreur pendant une instruction du FPU, une op\u00e9ration invalide, une division par 0, un d\u00e9passement num\u00e9rique, un r\u00e9sultat non exact, ou lorsque le bit 5 du registre CR0 = 1 non 17 Faute d'alignement Produite lorsque le bit 18 de CR0 et RFLAGS sont \u00e9gaux \u00e0 1. L'erreur est caus\u00e9e lorsqu'une r\u00e9f\u00e9rence de m\u00e9moire est non align\u00e9e. oui 18 Faute de v\u00e9rification de machine Produite lorsque le bit 6 du CR4 est \u00e9gal \u00e0 1. L'erreur est caus\u00e9e lorsque le CPU d\u00e9tecte une erreur de machine, comme un probl\u00e8me de bus, cache, m\u00e9moire, ou une erreur interne. non 19 Exception de variable a virgule SIMD L'interruption n\u00b019 est appel\u00e9 lorsqu'il y a une erreur avec les nombres \u00e0 virgule pendant une op\u00e9ration SSE : division par 0, d\u00e9passement num\u00e9rique, r\u00e9sultat non exact [...] non 20 Exception de virtualisation L'exception de virtualisation est appel\u00e9e lorsqu'il y a une violation de droits avec une instruction EPT non 21 \u00e0 31 r\u00e9serv\u00e9 // non /// Faute triple L'exception faute triple est ex\u00e9cut\u00e9e lorsqu'il y a une erreur pendant l'interruption de faute double (une erreur dans une erreur dans une erreur). L'interruption faute triple cause un red\u00e9marrage de la machine. non Codes d'erreur d'une faute de page BIT NOM DESCRIPTION 0 P (p=1) Violation de protection (p=0) la page n'est pas pr\u00e9sente 1 W (W=0) Caus\u00e9e par une lecture (W=1) Caus\u00e9e par une \u00e9criture 2 U (U=1) La page n'est pas utilisateur alors que CPL = 3 3 R (R=1) La page contient un bit r\u00e9serv\u00e9 4 I (I=1) Lecture \u00e0 cause d'une instruction 5 PK (PK=1) Violation de droit de cl\u00e9 6 SS (SS=1) Acc\u00e8s \u00e0 \"l'ombre de la pile\" 7-31 // R\u00e9serv\u00e9 Lors d'une faute de page, l'addresse qui a caus\u00e9 l'exception est stock\u00e9e dans CR2 . Codes d'erreur d'une faute g\u00e9n\u00e9rale de protection BIT NOM TAILLE DESCRIPTION 0 E 1 (E=1) Provient d'un appareil externe au processeur 1 TBL 2 (TBL=0) Provient de la GDT (TBL=1) Provient de l' IDT (TBL=2 & TBL=3) Provient de la LDT 3 Index 13 Index de la table s\u00e9lectionn\u00e9e dans TBL","title":"Codes d'erreur d'interruption"},{"location":"x86_64/interruption/CODE_DERREUR/#codes-derreur-dinterruption","text":"Toutes les interruptions entre 0 et 32 sont des interruptions d'erreur. Certains codes d'erreur peuvent \u00eatre corrig\u00e9s apr\u00e8s le retour de l'interruption. Cependant, d'autres ne peuvent pas l'\u00eatre. Code de l'interruption Nom Descriptions Contient un code d'erreur ? 0 Division par 0 Cette erreur est produite quand l'instruction DIV/IDIV est utilis\u00e9e avec un 0 non 1 Debug Cette erreur intentionnelle est g\u00e9n\u00e9ralement utilis\u00e9e pour d\u00e9boguer non 2 Interruption NMI L'interruption NMI est une interruption caus\u00e9e par des \u00e9l\u00e9ments externes comme la RAM non 3 Breakpoint Cette erreur intentionnelle est g\u00e9n\u00e9ralement utilis\u00e9e pour le d\u00e9bogage non 4 D\u00e9passement L'interruption 4 est caus\u00e9e lorsque l'instruction INTO est \u00e9x\u00e9cut\u00e9 alors que le bit 11 de RFLAGS est mis \u00e0 1. Note : l'erreur n'est pas possible en 64 bits car l'instruction INTO n'est pas disponible en mode long . non 5 D\u00e9passement de table L'interruption 5 est caus\u00e9e lorsque l'instruction BOUND est ex\u00e9cut\u00e9e quand op\u00e9rateur 1 n'est pas dans la taille de table d\u00e9finie dans l'op\u00e9rateur 2. Note : l'erreur n'est pas possible en 64 bits car l'instruction BOUND n'est pas disponible en mode long . non 6 Instruction non valide L'interruption 6 est caus\u00e9e lorsque : - On essaye d'acc\u00e9der \u00e0 un registre non existant - On essaye d'ex\u00e9cuter une instruction non disponible - UD est ex\u00e9cut\u00e9 non 7 Appareil non disponible L'interruption 7 est appel\u00e9e lorsqu'on essaye d'initialiser le FPU alors qu'il n'existe pas non 8 Faute Double La faute double est appel\u00e9e lorsqu'il y a une erreur pendant que l'interruption d'erreur est appel\u00e9e (une erreur dans une erreur) oui 9 Erreur de Segment de coprocesseur Cette erreur n'est plus utilis\u00e9e. non 10 TSS invalide L'interruption TSS invalide est ex\u00e9cut\u00e9e lorsque le s\u00e9lecteur de segment pour la TSS est invalide. Caus\u00e9e pendant un changement de t\u00e2che ou pendant l'acc\u00e8s de la TSS oui (code d'erreur de segment) 11 Segment non pr\u00e9sent L'interruption \"Segment non pr\u00e9sent\" est ex\u00e9cut\u00e9e lorsqu'on essaye de charger un segment qui a son bit pr\u00e9sent \u00e0 0 oui (code d'erreur de segment) 12 Segment de pile invalide L'interruption \"Segment de pile\" invalide est caus\u00e9e lorsque : - On charge un segment de pile qui n'est pas pr\u00e9sent - La v\u00e9rification de la limite de pile n'est pas possible - (64bit) On essaye de faire une op\u00e9ration qui fait une r\u00e9f\u00e9rence \u00e0 la m\u00e9moire en utilisant le pointeur de pile (RSP) qui contient une adresse m\u00e9moire non canonique - Le segment de pile n'est pas pr\u00e9sent pendant une op\u00e9ration qui fait r\u00e9f\u00e9rence au registre SS , (comme pop , push , iret ...) oui (code d'erreur de segment) 13 Faute g\u00e9n\u00e9rale de protection L'interruption n\u00b013 peut \u00eatre caus\u00e9e par beaucoup de raisons, comme : - L'\u00e9criture d'un 1 dans une zone du registre CR4 r\u00e9serv\u00e9e - L'utilisation une instruction SSE qui essaye d'acc\u00e9der une zone de la m\u00e9moire 128 bits qui n'est pas align\u00e9e en 16bit - Une pile de m\u00e9moire non align\u00e9e en 16bit [...]. Voir le manuel Intel pour plus d'informations (chap 3 6.15.13) oui (code d'erreur de segments) 14 Faute de page L'interruption n\u00b014 peut \u00eatre caus\u00e9e lorsque : - Il y a une erreur en relation avec le paging - On essaye d'acc\u00e9der \u00e0 une zone de la m\u00e9moire qui n'a pas de table pr\u00e9sente - On essaye de charger une table et que la zone ou on \u00e9x\u00e9cute le code n'est pas ex\u00e9cutable dans la page - Un probl\u00e8me d'autorisation est caus\u00e9 (ex: \u00e9crire dans une zone de la m\u00e9moire qui ne peut pas \u00eatre \u00e9crite) [...] Voir le manuel Intel pour plus d'informations (chap 3 6.15.14) oui (code d'erreur de page) 15 R\u00e9serv\u00e9 // non 16 Faute du FPU x87 L'interruption n\u00b016 est caus\u00e9e lorsqu'il y a une erreur pendant une instruction du FPU, une op\u00e9ration invalide, une division par 0, un d\u00e9passement num\u00e9rique, un r\u00e9sultat non exact, ou lorsque le bit 5 du registre CR0 = 1 non 17 Faute d'alignement Produite lorsque le bit 18 de CR0 et RFLAGS sont \u00e9gaux \u00e0 1. L'erreur est caus\u00e9e lorsqu'une r\u00e9f\u00e9rence de m\u00e9moire est non align\u00e9e. oui 18 Faute de v\u00e9rification de machine Produite lorsque le bit 6 du CR4 est \u00e9gal \u00e0 1. L'erreur est caus\u00e9e lorsque le CPU d\u00e9tecte une erreur de machine, comme un probl\u00e8me de bus, cache, m\u00e9moire, ou une erreur interne. non 19 Exception de variable a virgule SIMD L'interruption n\u00b019 est appel\u00e9 lorsqu'il y a une erreur avec les nombres \u00e0 virgule pendant une op\u00e9ration SSE : division par 0, d\u00e9passement num\u00e9rique, r\u00e9sultat non exact [...] non 20 Exception de virtualisation L'exception de virtualisation est appel\u00e9e lorsqu'il y a une violation de droits avec une instruction EPT non 21 \u00e0 31 r\u00e9serv\u00e9 // non /// Faute triple L'exception faute triple est ex\u00e9cut\u00e9e lorsqu'il y a une erreur pendant l'interruption de faute double (une erreur dans une erreur dans une erreur). L'interruption faute triple cause un red\u00e9marrage de la machine. non","title":"Codes d'erreur d'interruption"},{"location":"x86_64/interruption/CODE_DERREUR/#codes-derreur-dune-faute-de-page","text":"BIT NOM DESCRIPTION 0 P (p=1) Violation de protection (p=0) la page n'est pas pr\u00e9sente 1 W (W=0) Caus\u00e9e par une lecture (W=1) Caus\u00e9e par une \u00e9criture 2 U (U=1) La page n'est pas utilisateur alors que CPL = 3 3 R (R=1) La page contient un bit r\u00e9serv\u00e9 4 I (I=1) Lecture \u00e0 cause d'une instruction 5 PK (PK=1) Violation de droit de cl\u00e9 6 SS (SS=1) Acc\u00e8s \u00e0 \"l'ombre de la pile\" 7-31 // R\u00e9serv\u00e9 Lors d'une faute de page, l'addresse qui a caus\u00e9 l'exception est stock\u00e9e dans CR2 .","title":"Codes d'erreur d'une faute de page"},{"location":"x86_64/interruption/CODE_DERREUR/#codes-derreur-dune-faute-generale-de-protection","text":"BIT NOM TAILLE DESCRIPTION 0 E 1 (E=1) Provient d'un appareil externe au processeur 1 TBL 2 (TBL=0) Provient de la GDT (TBL=1) Provient de l' IDT (TBL=2 & TBL=3) Provient de la LDT 3 Index 13 Index de la table s\u00e9lectionn\u00e9e dans TBL","title":"Codes d'erreur d'une faute g\u00e9n\u00e9rale de protection"},{"location":"x86_64/noyau/types_de_noyaux/","text":"Types de noyaux Les noyaux sont class\u00e9 dans plusieurs parties, certains sont plus complexe que dautres... les noyaux sont divis\u00e9 dans 2 grandes parties types Les noyaux Monolithique Les noyaux monolithique, sont des noyaux qui contienne les driver syst\u00e8me de fichier etc dans le noyaux. Il a certains avantages et d'autres inconv\u00e9nient... Ils sont plus gros, et si il y a un crash dans le kernel tout plante Les micro-noyaux Les micro-noyaux, g\u00e9n\u00e9rallement plus petit que les noyaux monolithique. ce sont des noyaux qui, contrairement aux noyaux monolithique, ont tout leurs driver, syst\u00e8me de fichier etc en tant qu'application utilisateur. Il \u00e0 pour inconv\u00e9nient d'\u00eatre plus lent que les noyaux Monolithique sous types Il y a aussi d'autre sous genre de noyaux : les exonoyaux Les exonoyaux sont des petits noyaux qui ont pour but de laisser les applications d'avoir le plus d'acc\u00e8s aux appareils avec une protection. les noyaux modulaire les noyaux hybrides Les noyaux hybrides sont des noyaux monolithique qui sont divis\u00e9 dans plusieurs petit modules. Les modules sont cependant li\u00e9 au kernel pendant la compilation. les nano noyaux","title":"Types de noyaux"},{"location":"x86_64/noyau/types_de_noyaux/#types-de-noyaux","text":"Les noyaux sont class\u00e9 dans plusieurs parties, certains sont plus complexe que dautres... les noyaux sont divis\u00e9 dans 2 grandes parties","title":"Types de noyaux"},{"location":"x86_64/noyau/types_de_noyaux/#types","text":"Les noyaux Monolithique Les noyaux monolithique, sont des noyaux qui contienne les driver syst\u00e8me de fichier etc dans le noyaux. Il a certains avantages et d'autres inconv\u00e9nient... Ils sont plus gros, et si il y a un crash dans le kernel tout plante Les micro-noyaux Les micro-noyaux, g\u00e9n\u00e9rallement plus petit que les noyaux monolithique. ce sont des noyaux qui, contrairement aux noyaux monolithique, ont tout leurs driver, syst\u00e8me de fichier etc en tant qu'application utilisateur. Il \u00e0 pour inconv\u00e9nient d'\u00eatre plus lent que les noyaux Monolithique","title":"types"},{"location":"x86_64/noyau/types_de_noyaux/#sous-types","text":"Il y a aussi d'autre sous genre de noyaux : les exonoyaux Les exonoyaux sont des petits noyaux qui ont pour but de laisser les applications d'avoir le plus d'acc\u00e8s aux appareils avec une protection. les noyaux modulaire les noyaux hybrides Les noyaux hybrides sont des noyaux monolithique qui sont divis\u00e9 dans plusieurs petit modules. Les modules sont cependant li\u00e9 au kernel pendant la compilation. les nano noyaux","title":"sous types"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/APIC/","text":"Advanced Programmable Interrupt Controller","title":"Advanced Programmable Interrupt Controller"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/APIC/#advanced-programmable-interrupt-controller","text":"","title":"Advanced Programmable Interrupt Controller"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/COM/","text":"Attention! Cet article est en cours de r\u00e9daction. Introduction Un port COM \u00e9tait, \u00e0 l'\u00e9poque, couramment utilis\u00e9 comme port de communication. M\u00eame si aujourd'hui, l'USB a remplac\u00e9 le port COM, il reste n\u00e9anmoins tr\u00e8s utile et toujours support\u00e9 par nos machines. M\u00eame s'ils sont obsol\u00e8tes, les ports COM sont encore beaucoup utilis\u00e9s pour le d\u00e9veloppement de syst\u00e8mes d'exploitation. Ils sont tr\u00e8s simples \u00e0 impl\u00e9menter et sont tr\u00e8s utiles pour le d\u00e9bogage, car, dans presque toutes les machines virtuelles, on peut avoir la sortie d'un port COM vers un fichier, un terminal ou autre. Ils sont aussi tr\u00e8s utiles car on peut les initialiser tr\u00e8s t\u00f4t et donc avoir des informations de d\u00e9bogage efficacement. Par exemple, les ports s\u00e9rie peuvent envoyer des donn\u00e9es et en recevoir, ce qui pourrait, par exemple nous permettre de faire un terminal externe en utilisant uniquement ce port. La norme RS-232 (qui a \u00e9t\u00e9 r\u00e9vis\u00e9e maintes et maintes fois) est une norme qui standardise les ports s\u00e9rie. Existant depuis 1981, elle standardise les noms (COM1, COM2, COM3, etc), limite la vitesse \u00e0 19200 Baud (cela repr\u00e9sente th\u00e9oriquement un d\u00e9bit de 19200 bits par seconde), ce qui pourrait \u00eatre largement assez pour un petit terminal. la limite \u00e9tant calcul\u00e9e en Baud, celui-ci s'exprimant en bit/s, 1 baud correspond donc \u00e0 1 bit par seconde. La limite d\u00e9pend \u00e9galement de la distence du raccord avec le fil, un fil long a une capacit\u00e9 moindre qu'un fil court. On dit souvent Initialisation Chaque port a besoin d'\u00eatre initialis\u00e9 avant son utilisation. Pour commencer, il y a quelques valeurs constantes \u00e0 conna\u00eetre pour chaque port COM. Le port Com L'id du port Son IRQ COM1 0x3F8 4 COM2 0x2F8 3 COM3 0x3E8 4 COM4 0x2E8 3 Puis, il y a l'offset. Chaque offset a certaines particularit\u00e9s. (= ID DU PORT + OFFSET) offset action 0 Le port Data du COM, il est utilis\u00e9 pour envoyer et recevoir des donn\u00e9es, si le bit DLAB = 1 alors c'est pour mettre le diviseur du Baud (les bits inf\u00e9rieurs) 1 Le port Interrupt du COM, il est utilis\u00e9 pour activer les Interrupt du port, si le bit DLAB = 1 alors c'est pour mettre la valeur du diviseur (du Baud aussi mais pour les bits sup\u00e9rieurs) 2 L'identificateur d'Interrupt ou le controleur FIFO 3 le control de ligne (Le bit le plus haut est celui pour DLAB) 4 Le control de Modem 5 Le status de la ligne 6 Le status de Modem 7 Le scratch register Pour mettre DLAB il faut mettre le port comme indiqu\u00e9 : PORT + 3 = 0x80 = 128 = 0b10000000 outb(COM_PORT + 3, 0x80); Pour le d\u00e9sactiver, il faut juste remettre le bit 8 \u00e0 0. Les Baud Le port COM se met \u00e0 jour 115200 fois par seconde. Pour controller la vitesse, il faut mettre en place un diviseur, que l'on peut utiliser en activant le DLAB. Ensuite, il faut passer la valeur par l'offset 0 (les bits inf\u00e9rieurs) et 1 (les bits sup\u00e9rieurs). Exemple permettant de mettre un diviseur de 5 (alors le port auras un 'rate' de 115200 / 5) : outb(COM_PORT + 3, 0x80); // activer le DLAB outb(COM_PORT + 0, 5); // les bits les plus petits outb(COM_PORT + 1, 0); // les bits les plus hauts La taille des donn\u00e9es On peut mettre la taille des donn\u00e9es envoy\u00e9es au port COM par update. Celle-ci peut aller de 5 bits \u00e0 8 bits 5bits = 0 0 (0x0) 6bits = 0 1 (0x1) 7bits = 1 0 (0x2) 8bits = 1 1 (0x3) Pour d\u00e9finir la taille des donn\u00e9es, vous devez l'\u00e9crire dans le port de contr\u00f4le de ligne (les bits les plus petits) avoir configur\u00e9 le rate du port (et donc d'avoir activ\u00e9 le DLAB). outb(COM_PORT + 3, 0x3); // d\u00e9sactiver le DLAB + mettre la taille de donn\u00e9e \u00e0 8 donc un char/unsigned char en c++ Ressources https://www.sci.muni.cz/docs/pc/serport.txt","title":"COM"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/COM/#introduction","text":"Un port COM \u00e9tait, \u00e0 l'\u00e9poque, couramment utilis\u00e9 comme port de communication. M\u00eame si aujourd'hui, l'USB a remplac\u00e9 le port COM, il reste n\u00e9anmoins tr\u00e8s utile et toujours support\u00e9 par nos machines. M\u00eame s'ils sont obsol\u00e8tes, les ports COM sont encore beaucoup utilis\u00e9s pour le d\u00e9veloppement de syst\u00e8mes d'exploitation. Ils sont tr\u00e8s simples \u00e0 impl\u00e9menter et sont tr\u00e8s utiles pour le d\u00e9bogage, car, dans presque toutes les machines virtuelles, on peut avoir la sortie d'un port COM vers un fichier, un terminal ou autre. Ils sont aussi tr\u00e8s utiles car on peut les initialiser tr\u00e8s t\u00f4t et donc avoir des informations de d\u00e9bogage efficacement. Par exemple, les ports s\u00e9rie peuvent envoyer des donn\u00e9es et en recevoir, ce qui pourrait, par exemple nous permettre de faire un terminal externe en utilisant uniquement ce port. La norme RS-232 (qui a \u00e9t\u00e9 r\u00e9vis\u00e9e maintes et maintes fois) est une norme qui standardise les ports s\u00e9rie. Existant depuis 1981, elle standardise les noms (COM1, COM2, COM3, etc), limite la vitesse \u00e0 19200 Baud (cela repr\u00e9sente th\u00e9oriquement un d\u00e9bit de 19200 bits par seconde), ce qui pourrait \u00eatre largement assez pour un petit terminal. la limite \u00e9tant calcul\u00e9e en Baud, celui-ci s'exprimant en bit/s, 1 baud correspond donc \u00e0 1 bit par seconde. La limite d\u00e9pend \u00e9galement de la distence du raccord avec le fil, un fil long a une capacit\u00e9 moindre qu'un fil court. On dit souvent","title":"Introduction"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/COM/#initialisation","text":"Chaque port a besoin d'\u00eatre initialis\u00e9 avant son utilisation. Pour commencer, il y a quelques valeurs constantes \u00e0 conna\u00eetre pour chaque port COM. Le port Com L'id du port Son IRQ COM1 0x3F8 4 COM2 0x2F8 3 COM3 0x3E8 4 COM4 0x2E8 3 Puis, il y a l'offset. Chaque offset a certaines particularit\u00e9s. (= ID DU PORT + OFFSET) offset action 0 Le port Data du COM, il est utilis\u00e9 pour envoyer et recevoir des donn\u00e9es, si le bit DLAB = 1 alors c'est pour mettre le diviseur du Baud (les bits inf\u00e9rieurs) 1 Le port Interrupt du COM, il est utilis\u00e9 pour activer les Interrupt du port, si le bit DLAB = 1 alors c'est pour mettre la valeur du diviseur (du Baud aussi mais pour les bits sup\u00e9rieurs) 2 L'identificateur d'Interrupt ou le controleur FIFO 3 le control de ligne (Le bit le plus haut est celui pour DLAB) 4 Le control de Modem 5 Le status de la ligne 6 Le status de Modem 7 Le scratch register Pour mettre DLAB il faut mettre le port comme indiqu\u00e9 : PORT + 3 = 0x80 = 128 = 0b10000000 outb(COM_PORT + 3, 0x80); Pour le d\u00e9sactiver, il faut juste remettre le bit 8 \u00e0 0.","title":"Initialisation"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/COM/#les-baud","text":"Le port COM se met \u00e0 jour 115200 fois par seconde. Pour controller la vitesse, il faut mettre en place un diviseur, que l'on peut utiliser en activant le DLAB. Ensuite, il faut passer la valeur par l'offset 0 (les bits inf\u00e9rieurs) et 1 (les bits sup\u00e9rieurs). Exemple permettant de mettre un diviseur de 5 (alors le port auras un 'rate' de 115200 / 5) : outb(COM_PORT + 3, 0x80); // activer le DLAB outb(COM_PORT + 0, 5); // les bits les plus petits outb(COM_PORT + 1, 0); // les bits les plus hauts","title":"Les Baud"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/COM/#la-taille-des-donnees","text":"On peut mettre la taille des donn\u00e9es envoy\u00e9es au port COM par update. Celle-ci peut aller de 5 bits \u00e0 8 bits 5bits = 0 0 (0x0) 6bits = 0 1 (0x1) 7bits = 1 0 (0x2) 8bits = 1 1 (0x3) Pour d\u00e9finir la taille des donn\u00e9es, vous devez l'\u00e9crire dans le port de contr\u00f4le de ligne (les bits les plus petits) avoir configur\u00e9 le rate du port (et donc d'avoir activ\u00e9 le DLAB). outb(COM_PORT + 3, 0x3); // d\u00e9sactiver le DLAB + mettre la taille de donn\u00e9e \u00e0 8 donc un char/unsigned char en c++","title":"La taille des donn\u00e9es"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/COM/#ressources","text":"https://www.sci.muni.cz/docs/pc/serport.txt","title":"Ressources"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/LAPIC/","text":"Local APIC Le local apic est une entr\u00e9e de la MADT , son type est 0 Le nombre d'entr\u00e9e local apic dans la madt \u00e9quivaut au nombre de cpu, chaque cpu \u00e0 son local apic la structure de l'entre du local apic est offset/taille (en byte) nom 2 / 1 identifiant ACPI 3 / 1 identifiant APIC 4 / 4 flag du cpu","title":"Local APIC"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/LAPIC/#local-apic","text":"Le local apic est une entr\u00e9e de la MADT , son type est 0 Le nombre d'entr\u00e9e local apic dans la madt \u00e9quivaut au nombre de cpu, chaque cpu \u00e0 son local apic la structure de l'entre du local apic est offset/taille (en byte) nom 2 / 1 identifiant ACPI 3 / 1 identifiant APIC 4 / 4 flag du cpu","title":"Local APIC"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/MADT/","text":"MULTIPLE APIC DESCRIPTION TABLE","title":"MULTIPLE APIC DESCRIPTION TABLE"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/MADT/#multiple-apic-description-table","text":"","title":"MULTIPLE APIC DESCRIPTION TABLE"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/PIC/","text":"","title":"PIC"},{"location":"x86_64/p%C3%A9riph%C3%A9riques/PIT/","text":"","title":"PIT"},{"location":"x86_64/structures/GDT/","text":"Global Descriptor Table","title":"Global Descriptor Table"},{"location":"x86_64/structures/GDT/#global-descriptor-table","text":"","title":"Global Descriptor Table"},{"location":"x86_64/structures/IDT/","text":"Interrupt Descriptor Table","title":"Interrupt Descriptor Table"},{"location":"x86_64/structures/IDT/#interrupt-descriptor-table","text":"","title":"Interrupt Descriptor Table"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/","text":"0 - Introduction Ici nous ne ferrons pas de programmation, juste des bonnes d\u00e9finitions pour \u00eatre pr\u00e9par\u00e9. Pr\u00e9face (aka gate keeping) ce tutoriels vous expliqueras comment cr\u00e9er les bases d'un kernel il faut savoir que c'est tr\u00e8s dur et long. Beaucoup de kernel sont abandonn\u00e9... il faut \u00eatre d\u00e9termin\u00e9 et savoir coder, il faut bien connaitre le c ou c++ (le rust ne serra pas abord\u00e9 dans ces tutoriels) il faut aussi comprendre l'assembleur,cependant l'architecture de l'assembleur d\u00e9pend de vos envie. Et il ne serra pas \u00e9norm\u00e9ment pr\u00e9sent Il ne faut pas commencer un kernel en parral\u00e8le d'apprendre un language, ce serra beaucoup plus dur. Il ne faut pas croire que toutes vos application vont supporter windows, Vous ne pouvez pas coder un kernel en js Il est tr\u00e8s tr\u00e8s tr\u00e8s recommand\u00e9 d'utilis\u00e9 linux, windows complique la vie et wsl est tr\u00e8s lent Il faut lire et ne pas juste faire des b\u00eates copier coller. Introduction Qu'est ce qu'un kernel (ou noyau) ? Un noyau est l'une des plus grosse partie d'un syst\u00e8me d'exploitation. Il permet aux application utilisateur d'acc\u00e8der au compostants et p\u00e9riph\u00e9riques. Il g\u00e8re la m\u00e9moire, les fichier, les processus, les drivers, les processeur, une partie de la s\u00e9curit\u00e9 etc... Un noyau est l'\u00e9tape apr\u00e8s le boot loader, ou le chargeur de boot. Qu'est ce qu'un bootloader ? Un bootloader est g\u00e9n\u00e9rallement ce qui permet de faire passer de la machine qui d\u00e9marre \u00e0 une machine pr\u00eate pour faire booter/d\u00e9marrer le noyau Il est tr\u00e8s important et tr\u00e8s compliqu\u00e9, il est recommand\u00e9 de ne pas \u00e9crire son propre bootloader quand on d\u00e9bute, cela va vite vous d\u00e9courager... Un bootloader peut aussi charger des \u00e9l\u00e9ments important pour le kernel, comme des modules charg\u00e9 dans le disques, l'A20 etc... L'architecture L'architecture c'est comment un processeur est structur\u00e9, comment il fonctionne, quel est son language assembly. Il y a plusieurs architecture et un kernel peut en supporter plusieurs en m\u00eame temps : x86 riscV arm powerpc et bien d'autres l'architecture est importante, ici nous prenons le x86 car c'est l'architecture la plus utilis\u00e9e. le x86 est divis\u00e9 en modes : nom anglais nom fran\u00e7ais taille de registre real mode mode r\u00e9el 16/20 bit protected mode mode prot\u00e9g\u00e9 32bit long mode mode long 64bit nous utiliserons ici le mode long car il est le plus r\u00e9cent, m\u00eame si il a moins de documentation que le mode prot\u00e9g\u00e9. Comment ? Comment coder un kernel ? Il faut prendre la route que l'on veut, mais il y a des \u00e9l\u00e9ments important qu'il faut faire dans un ordre \u00e0 peut pr\u00e8s pr\u00e9cis, Vous pouvez dans certains cas faire l'ordre que vous voulez mais il faut quand m\u00eame une route... car parfois on se pose la question : quoi faire apr\u00e8s ? Donc cette route ici est recommand\u00e9 mais vous faites comme vous le souhaitez d\u00e9marrage com // pour le debugging gdt idt interruption // pour le debugging d'erreur pit gestion de m\u00e9moire physique pagination multitache \u00e0 partir d'ici tout deviens tr\u00e8s subjectif vous pouvez enchainer sur le smp, le syst\u00e8me de fichier, les t\u00e2ches utilisatrices, etc... [EN COURS D'ECRITURE]","title":"0 - Introduction"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/#0-introduction","text":"Ici nous ne ferrons pas de programmation, juste des bonnes d\u00e9finitions pour \u00eatre pr\u00e9par\u00e9.","title":"0 - Introduction"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/#preface-aka-gate-keeping","text":"ce tutoriels vous expliqueras comment cr\u00e9er les bases d'un kernel il faut savoir que c'est tr\u00e8s dur et long. Beaucoup de kernel sont abandonn\u00e9... il faut \u00eatre d\u00e9termin\u00e9 et savoir coder, il faut bien connaitre le c ou c++ (le rust ne serra pas abord\u00e9 dans ces tutoriels) il faut aussi comprendre l'assembleur,cependant l'architecture de l'assembleur d\u00e9pend de vos envie. Et il ne serra pas \u00e9norm\u00e9ment pr\u00e9sent Il ne faut pas commencer un kernel en parral\u00e8le d'apprendre un language, ce serra beaucoup plus dur. Il ne faut pas croire que toutes vos application vont supporter windows, Vous ne pouvez pas coder un kernel en js Il est tr\u00e8s tr\u00e8s tr\u00e8s recommand\u00e9 d'utilis\u00e9 linux, windows complique la vie et wsl est tr\u00e8s lent Il faut lire et ne pas juste faire des b\u00eates copier coller.","title":"Pr\u00e9face (aka gate keeping)"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/#introduction","text":"","title":"Introduction"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/#quest-ce-quun-kernel-ou-noyau","text":"Un noyau est l'une des plus grosse partie d'un syst\u00e8me d'exploitation. Il permet aux application utilisateur d'acc\u00e8der au compostants et p\u00e9riph\u00e9riques. Il g\u00e8re la m\u00e9moire, les fichier, les processus, les drivers, les processeur, une partie de la s\u00e9curit\u00e9 etc... Un noyau est l'\u00e9tape apr\u00e8s le boot loader, ou le chargeur de boot.","title":"Qu'est ce qu'un kernel (ou noyau) ?"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/#quest-ce-quun-bootloader","text":"Un bootloader est g\u00e9n\u00e9rallement ce qui permet de faire passer de la machine qui d\u00e9marre \u00e0 une machine pr\u00eate pour faire booter/d\u00e9marrer le noyau Il est tr\u00e8s important et tr\u00e8s compliqu\u00e9, il est recommand\u00e9 de ne pas \u00e9crire son propre bootloader quand on d\u00e9bute, cela va vite vous d\u00e9courager... Un bootloader peut aussi charger des \u00e9l\u00e9ments important pour le kernel, comme des modules charg\u00e9 dans le disques, l'A20 etc...","title":"Qu'est ce qu'un bootloader ?"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/#larchitecture","text":"L'architecture c'est comment un processeur est structur\u00e9, comment il fonctionne, quel est son language assembly. Il y a plusieurs architecture et un kernel peut en supporter plusieurs en m\u00eame temps : x86 riscV arm powerpc et bien d'autres l'architecture est importante, ici nous prenons le x86 car c'est l'architecture la plus utilis\u00e9e. le x86 est divis\u00e9 en modes : nom anglais nom fran\u00e7ais taille de registre real mode mode r\u00e9el 16/20 bit protected mode mode prot\u00e9g\u00e9 32bit long mode mode long 64bit nous utiliserons ici le mode long car il est le plus r\u00e9cent, m\u00eame si il a moins de documentation que le mode prot\u00e9g\u00e9.","title":"L'architecture"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/#comment","text":"Comment coder un kernel ? Il faut prendre la route que l'on veut, mais il y a des \u00e9l\u00e9ments important qu'il faut faire dans un ordre \u00e0 peut pr\u00e8s pr\u00e9cis, Vous pouvez dans certains cas faire l'ordre que vous voulez mais il faut quand m\u00eame une route... car parfois on se pose la question : quoi faire apr\u00e8s ? Donc cette route ici est recommand\u00e9 mais vous faites comme vous le souhaitez d\u00e9marrage com // pour le debugging gdt idt interruption // pour le debugging d'erreur pit gestion de m\u00e9moire physique pagination multitache \u00e0 partir d'ici tout deviens tr\u00e8s subjectif vous pouvez enchainer sur le smp, le syst\u00e8me de fichier, les t\u00e2ches utilisatrices, etc...","title":"Comment ?"},{"location":"x86_64/tutoriels/premiers_pas/00-Introduction/#en-cours-decriture","text":"","title":"[EN COURS D'ECRITURE]"},{"location":"x86_64/tutoriels/premiers_pas/01-Hello%2C_World%21/","text":"","title":"01 Hello, World!"},{"location":"x86_64/tutoriels/premiers_pas/02-Segmentation/","text":"","title":"02 Segmentation"},{"location":"x86_64/tutoriels/premiers_pas/03-Interuption/","text":"","title":"03 Interuption"},{"location":"x86_64/tutoriels/premiers_pas/04-Memoire/","text":"","title":"04 Memoire"},{"location":"x86_64/tutoriels/premiers_pas/05-Pagination/","text":"","title":"05 Pagination"},{"location":"x86_64/tutoriels/premiers_pas/06-Multit%C3%A2che/","text":"","title":"06 Multit\u00e2che"},{"location":"x86_64/tutoriels/premiers_pas/07-T%C3%A2che_Utilisateur/","text":"","title":"07 T\u00e2che Utilisateur"},{"location":"x86_64/tutoriels/premiers_pas/08-Epilogue/","text":"","title":"08 Epilogue"},{"location":"x86_64/tutoriels/smp/SMP/","text":"Symmetric Multiprocessing Un peu de vocabulaire Les termes \"coeurs\" et \"CPU\" seront utilis\u00e9s tout au long de ce tutoriel. Ils repr\u00e9sentent tous deux la m\u00eame entit\u00e9, \u00e0 savoir, une unit\u00e9 centrale de traitement. Vous aurez remarqu\u00e9 que ce groupe nominal barbare peut \u00eatre litt\u00e9ralement traduit par \"Central Processing Unit\", ou CPU. Le terme \"thread\" d\u00e9signe un flot d'instructions, ex\u00e9cut\u00e9 en parall\u00e8le \u00e0 d'autres threads ; ou, autrement dit, un flot d'instructions dont l'ex\u00e9cution n'interf\u00e8re g\u00e9n\u00e9ralement pas avec l'ex\u00e9cution d'un autre flot d'instructions. Pr\u00e9r\u00e9quis Dans ce tutoriel, pour impl\u00e9menter le SMP, nous prenons en compte que vous avez d\u00e9j\u00e0 impl\u00e9ment\u00e9 la base de votre noyau : IDT GDT MADT LAPIC APIC Paging On consid\u00e8re aussi que la structure de votre noyau est compos\u00e9e de ces caract\u00e9ristiques : Une architecture higher-half Un support du 64 bits Un syst\u00e8me de temporisation Introduction Qu'est ce que le SMP ? SMP est un sigle signifiant \"Symetric Multi Processing\", que l'on pourrait litt\u00e9ralement traduire par \"Multi-tra\u00eetement sym\u00e9trique\". On utilise ce terme pour parler d'un syst\u00e8me multiprocesseur, qui exploite plusieurs CPUs de fa\u00e7on parall\u00e8le. Un noyau qui supporte le SMP peut b\u00e9n\u00e9ficier d'\u00e9normes am\u00e9liorations de performances. En sachant que - g\u00e9n\u00e9ralement - un processeur poss\u00e8de 2 threads par coeur, pour un processeur de 8 coeurs il y aura 16 threads exploitables. Le SMP est diff\u00e9rent de NUMA, les processeurs NUMA sont des processeurs dont certains de leurs coeurs n'ont pas acc\u00e8s \u00e0 toute la m\u00e9moire. Il est utile de savoir qu'il faudra impl\u00e9menter les interruptions APIC pour les autres CPUs, ce qui n'est pas abord\u00e9 dans ce tutoriel (pour l'instant). Obtenir le num\u00e9ro du coeur actuel Obtenir le numero du coeur actuel est tr\u00e8s important pour plus tard, il permet d'identifier le CPU sur lequel on travaille. Pour obtenir l'identifiant du CPU actuel on doit utiliser l' APIC . Le num\u00e9ro du CPU est contenu dans le registre 20 de l'APIC, et il est situ\u00e9 du 24\u00e8me au 32\u00e8me bit, il faut donc d\u00e9caler \u00e0 droite la valeur lue de 24 bits. #define LAPIC_REGISTER 20 uint32_t get_current_processor_id() { return apic::read(LAPIC_REGISTER) >> 24; } Obtenir les entr\u00e9es Local APIC Voir : LAPIC Pour commencer \u00e0 utiliser le SMP, il faut obtenir les entr\u00e9es LAPIC de la tablea MADT. Chaque CPU pos\u00e8de une entr\u00e9e LAPIC. Pour connaitre le nombre total de CPUs il suffit donc de compter le nombre de LAPIC dans la MADT. Ces entr\u00e9es LAPIC ont deux valeurs importantes: ACPI_ID : un identifiant utilis\u00e9 par l'ACPI, ACIC_ID : un identifiant utilis\u00e9 par l'APIC pendant l'initialisation. G\u00e9n\u00e9ralement, sur les processeurs modernes, ACPI_ID et APIC_ID sont \u00e9gaux, mais ce n'est pas toujours le cas. Pour utiliser les autres CPU, il faudra faire attention : le CPU principal (celui sur lequel votre kernel d\u00e9marre) est aussi dans la liste. Il faut donc v\u00e9rifier que le CPU que l'on souhaite utiliser est libre. Pour cela, il suffit de comparer l'identifiant du CPU actuel avec l'identifiant du CPU de l'entr\u00e9e LAPIC . // lapic_entry : entr\u00e9e LAPIC que l'on est en train de manipuler if (get_current_processor_id() == lapic_entry.apic_id) { // On est actuellement en train de traiter le CPU principal, attention \u00e0 ne pas faire planter votre kernel! } else { // Ce CPU n'est pas le CPU principal, on peut donc s'en servir librement. } Pre-Initialisation Pour utiliser les CPUs, il faut d'abord les pr\u00e9parer, en particulier pr\u00e9parer l'IDT, la table de page, la GDT, le code d'initialisation... On place donc tout ceci de cette fa\u00e7on : Entr\u00e9e Adresse Code du trampoline 0x1000 Pile 0x570 GDT 0x580 IDT 0x590 Table de page 0x600 Adresse de saut 0x610 Il faut savoir que tout ceci est temporaire, tout devra \u00eatre remplac\u00e9 plus tard. GDT + IDT Pour stocker la GDT et l'IDT, c'est assez simple. Il existe deux instructions en 64 bits qui sont d\u00e9di\u00e9es: sgdt [adresse] pour stocker la GDT \u00e0 une adresse pr\u00e9cise, sidt [adresse] pour stocker l'IDT \u00e0 une adresse pr\u00e9cise. Dans notre cas on a donc: sgdt [0x580] ; stockage de la GDT sidt [0x590] ; stockage de l'IDT Pile Pour initialiser la pile on doit stocker une adresse valide \u00e0 l'adresse 0x570 : POKE(570) = stack_address + stack_size; Code du trampoline Pour le trampoline nous avons besoin d'un code \u00e9crit en assembleur, d\u00e9limit\u00e9 par trampoline_start et trampoline_end . Le code trampoline doit \u00eatre charg\u00e9 \u00e0 partir de l'adresse 0x1000 , ce qui donne pour la partie cpp : #define TRAMPOLINE_START 0x1000 // On calcule la taille du programme trampoline pour copier son contenu uint64_t trampoline_len = (uint64_t)&trampoline_end - (uint64_t)&trampoline_start; // On copie le code trampoline au bon endroit memcpy((void *)TRAMPOLINE_START, &trampoline_start, trampoline_len); et dans le code assembleur, on sp\u00e9cifie le code trampoline avec : trampoline_start: ; code du trampoline trampoline_end: Addresse de saut L'addresse de saut est l'adresse \u00e0 laquelle va se rendre le CPU juste apr\u00e8s son initialisaiton, on y met donc le programme principal. Table de page pour le futur CPU Pour le futur CPU on peut choisir de prende une copie de la table de page actuelle, mais attention il faut effectuer une copie, et pas simplement une r\u00e9f\u00e9rence \u00e0 l'ancienne, sinon des \u00e9v\u00e8nements \u00e9tranges peuvent avoir lieu. Chargement du CPU Pour initialiser le nouveau CPU, il faut demander \u00e0 l'APIC de le charger. Pour ce faire, on utilise les deux registres de commande d'interuptions ICR1 (registre 0x0300 ) et ICR2 . Pour initialiser le nouveau CPU il faut envoyer \u00e0 l'APIC l'identifiant du nouveau CPU dans ICR2 et l'interuption d'initialisation dans ICR1 : // On \u00e9crit l'identifiant du nouveau CPU dans ICR2, attention \u00e0 bien utiliser son identifiant APIC write(icr2, (apic_id << 24)); // On envoie la demande d'initialisation write(icr1, 0x500); L'initialisation peut \u00eatre un peu longue, il faut donc attendre au moins 10 millisecondes avant de l'utiliser. On commence par envoyer le nouveau CPU \u00e0 l'adresse trampoline, l\u00e0 encore \u00e0 travers l'APIC. L'identifiant du CPU va encore dans ICR2 , et l'instruction \u00e0 \u00e9crire dans ICR1 devient 0x0600 | (trampoline_addr >> 12) : // Chargement de l'identifiant du nouveau CPU write(icr2, (apic_id << 24)); // Chargement de l'adresse trampoline write(icr1, 0x600 | ((uint32_t)trampoline_addr / 4096)); Le code du trampoline Pour commencer, on peut simplement utiliser le code suivant, qui envoie le caract\u00e8re a sur le port COM0 . Ce code est bien s\u00fbr temporaire, mais permet de v\u00e9rifier que le nouveau CPU d\u00e9marre correctement. mov al, 'a' mov dx, 0x3F8 out dx, al Lorsque le CPU est initialis\u00e9 il est en 16 bits, il le sera donc aussi lors de l'ex\u00e9cution du trampoline. Il faut donc penser \u00e0 modifier la configuration du CPU pour le passer en 64 bits. On aura donc 3 parties dans le trampoline : pour passer de 16 \u00e0 32 bits, puis de 32 \u00e0 64 bits et enfin le trampoline final en 64 bits : [16 bits] trampoline_start: trampoline_16: ;... [32 bits] trampoline_32: ;... [64 bits] trampoline_64: ;... trampoline_end: Le code 16 bits Note : trampoline_addr est l'addresse ou vous avez plac\u00e9 votre trampoline, dans ce cas, 0x1000 . On commence par passer de 16 bits \u00e0 32 bits. Pour cela, il faut initialiser une nouvelle GDT et mettre le bit 0 du cr0 \u00e0 1 pour activer le mode prot\u00e9g\u00e9 : cli ; On d\u00e9sactive les interrupt, c'est important pendant le passage de 16 \u00e0 32 bits mov ax, 0x0 ; On initialise tous les registres \u00e0 0 mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax On doit cr\u00e9er une GDT 32 bits pour le 32 bit, on proc\u00e8de donc ainsi : align 16 gdt_32: dw gdt_32_end - gdt_32_start - 1 dd gdt_32_start - trampoline_start + trampoline_addr align 16 gdt_32_start: ; descripteur NULL dq 0 ; descripteur de code dq 0x00CF9A000000FFFF ; descripteur de donn\u00e9 dq 0x00CF92000000FFFF gdt_32_end: Et on doit maintenant charger cette GDT : lgdt [gdt_32 - trampoline_start + trampoline_addr] On peut donc activer le mode prot\u00e9g\u00e9 : mov eax, cr0 or al, 0x1 mov cr0, eax ...Puis sauter en changeant le segment code vers l'entr\u00e9e 0x8 de la GDT : jmp 0x8:(trampoline32 - trampoline_start + trampoline_addr) Le code 32 bits On doit dans un premier temps charger la table de page dans le cr3 , puis activer le paging et le PAE du cr4 en activant les bits 5 et 7 du registre cr4 : ; Chargement de la table de page : mov eax, dword [0x600] mov cr3, eax ; Activation du paging et du PAE mov eax, cr4 or eax, 1 << 5 or eax, 1 << 7 mov cr4, eax On active maintenant le mode long, en activant le 8\u00e8me bit de l'EFER ( Extended Feature Enable Register ) : mov ecx, 0xc0000080 ; registre efer rdmsr or eax,1 << 8 wrmsr On active ensuite le paging en \u00e9crivant le 31\u00e8me bit du registre cr0 : mov eax, cr0 or eax, 1 << 31 mov cr0, eax Et pour finir il faut cr\u00e9er puis charger une GDT 64 bits : align 16 gdt_64: dw gdt_64_end - gdt_64_start - 1 dd gdt_64_start - trampoline_start + trampoline_addr align 16 gdt_64_start: ; null selector 0x0 dq 0 ; cs selector 8 dq 0x00AF98000000FFFF ; ds selector 16 dq 0x00CF92000000FFFF gdt_64_end: ; Chargement de la nouvelle GDT lgdt [gdt_64 - trampoline_start + trampoline_addr] On peut ensuite passer \u00e0 la section 64 bits, en utilisant l'instruction jmp comme pr\u00e9c\u00e9dement : ; jmp 0x8 : permet de charger le segment de code de la GDT jmp 0x8:(trampoline64 - trampoline_start + trampoline_addr) Le code 64 bits On commence par d\u00e9finir les valeurs des registre ds , ss et es en fonction de la nouvelle GDT : mov ax, 0x10 mov ds, ax mov es, ax mov ss, ax mov ax, 0x0 mov fs, ax mov gs, ax Et on charge ensuite la GDT, l'IDT et la stack au bon endroit : ; Chargement de la GDT lgdt [0x580] ; Chargement de l'IDT lidt [0x590] ; Chargement de la stack mov rsp, [0x570] mov rbp, 0x0 On doit ensuite passer du code trampoline au code physique \u00e0 ex\u00e9cuter sur ce nouveau CPU. C'est \u00e0 ce moment que on doit activer certains bits de cr4 et cr0 et surtout le SSE ! jmp virtual_code virtual_code: mov rax, cr0 ; Activation du monitoring de multi-processeur et de l'\u00e9mulation btr eax, 2 bts eax, 1 mov cr0, rax Enfin, pour terminer l'initialisation de ce nouveau CPU il faut finir par : mov rax, [0x610] jmp rax Note de fin Le nouveau CPU est maintenant fonctionnel, mais ce n'est pas encore fini. Il faut mettre en place un syst\u00e8me de lock pour la communication inter-CPU, mettre \u00e0 jour le multitasking pour utiliser ce nouveau CPU, charger une GDT, un IDT et une stack unique... Ressources manuel intel osdev","title":"Symmetric Multiprocessing"},{"location":"x86_64/tutoriels/smp/SMP/#symmetric-multiprocessing","text":"","title":"Symmetric Multiprocessing"},{"location":"x86_64/tutoriels/smp/SMP/#un-peu-de-vocabulaire","text":"Les termes \"coeurs\" et \"CPU\" seront utilis\u00e9s tout au long de ce tutoriel. Ils repr\u00e9sentent tous deux la m\u00eame entit\u00e9, \u00e0 savoir, une unit\u00e9 centrale de traitement. Vous aurez remarqu\u00e9 que ce groupe nominal barbare peut \u00eatre litt\u00e9ralement traduit par \"Central Processing Unit\", ou CPU. Le terme \"thread\" d\u00e9signe un flot d'instructions, ex\u00e9cut\u00e9 en parall\u00e8le \u00e0 d'autres threads ; ou, autrement dit, un flot d'instructions dont l'ex\u00e9cution n'interf\u00e8re g\u00e9n\u00e9ralement pas avec l'ex\u00e9cution d'un autre flot d'instructions.","title":"Un peu de vocabulaire"},{"location":"x86_64/tutoriels/smp/SMP/#prerequis","text":"Dans ce tutoriel, pour impl\u00e9menter le SMP, nous prenons en compte que vous avez d\u00e9j\u00e0 impl\u00e9ment\u00e9 la base de votre noyau : IDT GDT MADT LAPIC APIC Paging On consid\u00e8re aussi que la structure de votre noyau est compos\u00e9e de ces caract\u00e9ristiques : Une architecture higher-half Un support du 64 bits Un syst\u00e8me de temporisation","title":"Pr\u00e9r\u00e9quis"},{"location":"x86_64/tutoriels/smp/SMP/#introduction","text":"Qu'est ce que le SMP ? SMP est un sigle signifiant \"Symetric Multi Processing\", que l'on pourrait litt\u00e9ralement traduire par \"Multi-tra\u00eetement sym\u00e9trique\". On utilise ce terme pour parler d'un syst\u00e8me multiprocesseur, qui exploite plusieurs CPUs de fa\u00e7on parall\u00e8le. Un noyau qui supporte le SMP peut b\u00e9n\u00e9ficier d'\u00e9normes am\u00e9liorations de performances. En sachant que - g\u00e9n\u00e9ralement - un processeur poss\u00e8de 2 threads par coeur, pour un processeur de 8 coeurs il y aura 16 threads exploitables. Le SMP est diff\u00e9rent de NUMA, les processeurs NUMA sont des processeurs dont certains de leurs coeurs n'ont pas acc\u00e8s \u00e0 toute la m\u00e9moire. Il est utile de savoir qu'il faudra impl\u00e9menter les interruptions APIC pour les autres CPUs, ce qui n'est pas abord\u00e9 dans ce tutoriel (pour l'instant).","title":"Introduction"},{"location":"x86_64/tutoriels/smp/SMP/#obtenir-le-numero-du-coeur-actuel","text":"Obtenir le numero du coeur actuel est tr\u00e8s important pour plus tard, il permet d'identifier le CPU sur lequel on travaille. Pour obtenir l'identifiant du CPU actuel on doit utiliser l' APIC . Le num\u00e9ro du CPU est contenu dans le registre 20 de l'APIC, et il est situ\u00e9 du 24\u00e8me au 32\u00e8me bit, il faut donc d\u00e9caler \u00e0 droite la valeur lue de 24 bits. #define LAPIC_REGISTER 20 uint32_t get_current_processor_id() { return apic::read(LAPIC_REGISTER) >> 24; }","title":"Obtenir le num\u00e9ro du coeur actuel"},{"location":"x86_64/tutoriels/smp/SMP/#obtenir-les-entrees-local-apic","text":"Voir : LAPIC Pour commencer \u00e0 utiliser le SMP, il faut obtenir les entr\u00e9es LAPIC de la tablea MADT. Chaque CPU pos\u00e8de une entr\u00e9e LAPIC. Pour connaitre le nombre total de CPUs il suffit donc de compter le nombre de LAPIC dans la MADT. Ces entr\u00e9es LAPIC ont deux valeurs importantes: ACPI_ID : un identifiant utilis\u00e9 par l'ACPI, ACIC_ID : un identifiant utilis\u00e9 par l'APIC pendant l'initialisation. G\u00e9n\u00e9ralement, sur les processeurs modernes, ACPI_ID et APIC_ID sont \u00e9gaux, mais ce n'est pas toujours le cas. Pour utiliser les autres CPU, il faudra faire attention : le CPU principal (celui sur lequel votre kernel d\u00e9marre) est aussi dans la liste. Il faut donc v\u00e9rifier que le CPU que l'on souhaite utiliser est libre. Pour cela, il suffit de comparer l'identifiant du CPU actuel avec l'identifiant du CPU de l'entr\u00e9e LAPIC . // lapic_entry : entr\u00e9e LAPIC que l'on est en train de manipuler if (get_current_processor_id() == lapic_entry.apic_id) { // On est actuellement en train de traiter le CPU principal, attention \u00e0 ne pas faire planter votre kernel! } else { // Ce CPU n'est pas le CPU principal, on peut donc s'en servir librement. }","title":"Obtenir les entr\u00e9es Local APIC"},{"location":"x86_64/tutoriels/smp/SMP/#pre-initialisation","text":"Pour utiliser les CPUs, il faut d'abord les pr\u00e9parer, en particulier pr\u00e9parer l'IDT, la table de page, la GDT, le code d'initialisation... On place donc tout ceci de cette fa\u00e7on : Entr\u00e9e Adresse Code du trampoline 0x1000 Pile 0x570 GDT 0x580 IDT 0x590 Table de page 0x600 Adresse de saut 0x610 Il faut savoir que tout ceci est temporaire, tout devra \u00eatre remplac\u00e9 plus tard.","title":"Pre-Initialisation"},{"location":"x86_64/tutoriels/smp/SMP/#gdt-idt","text":"Pour stocker la GDT et l'IDT, c'est assez simple. Il existe deux instructions en 64 bits qui sont d\u00e9di\u00e9es: sgdt [adresse] pour stocker la GDT \u00e0 une adresse pr\u00e9cise, sidt [adresse] pour stocker l'IDT \u00e0 une adresse pr\u00e9cise. Dans notre cas on a donc: sgdt [0x580] ; stockage de la GDT sidt [0x590] ; stockage de l'IDT","title":"GDT + IDT"},{"location":"x86_64/tutoriels/smp/SMP/#pile","text":"Pour initialiser la pile on doit stocker une adresse valide \u00e0 l'adresse 0x570 : POKE(570) = stack_address + stack_size;","title":"Pile"},{"location":"x86_64/tutoriels/smp/SMP/#code-du-trampoline","text":"Pour le trampoline nous avons besoin d'un code \u00e9crit en assembleur, d\u00e9limit\u00e9 par trampoline_start et trampoline_end . Le code trampoline doit \u00eatre charg\u00e9 \u00e0 partir de l'adresse 0x1000 , ce qui donne pour la partie cpp : #define TRAMPOLINE_START 0x1000 // On calcule la taille du programme trampoline pour copier son contenu uint64_t trampoline_len = (uint64_t)&trampoline_end - (uint64_t)&trampoline_start; // On copie le code trampoline au bon endroit memcpy((void *)TRAMPOLINE_START, &trampoline_start, trampoline_len); et dans le code assembleur, on sp\u00e9cifie le code trampoline avec : trampoline_start: ; code du trampoline trampoline_end:","title":"Code du trampoline"},{"location":"x86_64/tutoriels/smp/SMP/#addresse-de-saut","text":"L'addresse de saut est l'adresse \u00e0 laquelle va se rendre le CPU juste apr\u00e8s son initialisaiton, on y met donc le programme principal.","title":"Addresse de saut"},{"location":"x86_64/tutoriels/smp/SMP/#table-de-page-pour-le-futur-cpu","text":"Pour le futur CPU on peut choisir de prende une copie de la table de page actuelle, mais attention il faut effectuer une copie, et pas simplement une r\u00e9f\u00e9rence \u00e0 l'ancienne, sinon des \u00e9v\u00e8nements \u00e9tranges peuvent avoir lieu.","title":"Table de page pour le futur CPU"},{"location":"x86_64/tutoriels/smp/SMP/#chargement-du-cpu","text":"Pour initialiser le nouveau CPU, il faut demander \u00e0 l'APIC de le charger. Pour ce faire, on utilise les deux registres de commande d'interuptions ICR1 (registre 0x0300 ) et ICR2 . Pour initialiser le nouveau CPU il faut envoyer \u00e0 l'APIC l'identifiant du nouveau CPU dans ICR2 et l'interuption d'initialisation dans ICR1 : // On \u00e9crit l'identifiant du nouveau CPU dans ICR2, attention \u00e0 bien utiliser son identifiant APIC write(icr2, (apic_id << 24)); // On envoie la demande d'initialisation write(icr1, 0x500); L'initialisation peut \u00eatre un peu longue, il faut donc attendre au moins 10 millisecondes avant de l'utiliser. On commence par envoyer le nouveau CPU \u00e0 l'adresse trampoline, l\u00e0 encore \u00e0 travers l'APIC. L'identifiant du CPU va encore dans ICR2 , et l'instruction \u00e0 \u00e9crire dans ICR1 devient 0x0600 | (trampoline_addr >> 12) : // Chargement de l'identifiant du nouveau CPU write(icr2, (apic_id << 24)); // Chargement de l'adresse trampoline write(icr1, 0x600 | ((uint32_t)trampoline_addr / 4096));","title":"Chargement du CPU"},{"location":"x86_64/tutoriels/smp/SMP/#le-code-du-trampoline","text":"Pour commencer, on peut simplement utiliser le code suivant, qui envoie le caract\u00e8re a sur le port COM0 . Ce code est bien s\u00fbr temporaire, mais permet de v\u00e9rifier que le nouveau CPU d\u00e9marre correctement. mov al, 'a' mov dx, 0x3F8 out dx, al Lorsque le CPU est initialis\u00e9 il est en 16 bits, il le sera donc aussi lors de l'ex\u00e9cution du trampoline. Il faut donc penser \u00e0 modifier la configuration du CPU pour le passer en 64 bits. On aura donc 3 parties dans le trampoline : pour passer de 16 \u00e0 32 bits, puis de 32 \u00e0 64 bits et enfin le trampoline final en 64 bits : [16 bits] trampoline_start: trampoline_16: ;... [32 bits] trampoline_32: ;... [64 bits] trampoline_64: ;... trampoline_end:","title":"Le code du trampoline"},{"location":"x86_64/tutoriels/smp/SMP/#le-code-16-bits","text":"Note : trampoline_addr est l'addresse ou vous avez plac\u00e9 votre trampoline, dans ce cas, 0x1000 . On commence par passer de 16 bits \u00e0 32 bits. Pour cela, il faut initialiser une nouvelle GDT et mettre le bit 0 du cr0 \u00e0 1 pour activer le mode prot\u00e9g\u00e9 : cli ; On d\u00e9sactive les interrupt, c'est important pendant le passage de 16 \u00e0 32 bits mov ax, 0x0 ; On initialise tous les registres \u00e0 0 mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax On doit cr\u00e9er une GDT 32 bits pour le 32 bit, on proc\u00e8de donc ainsi : align 16 gdt_32: dw gdt_32_end - gdt_32_start - 1 dd gdt_32_start - trampoline_start + trampoline_addr align 16 gdt_32_start: ; descripteur NULL dq 0 ; descripteur de code dq 0x00CF9A000000FFFF ; descripteur de donn\u00e9 dq 0x00CF92000000FFFF gdt_32_end: Et on doit maintenant charger cette GDT : lgdt [gdt_32 - trampoline_start + trampoline_addr] On peut donc activer le mode prot\u00e9g\u00e9 : mov eax, cr0 or al, 0x1 mov cr0, eax ...Puis sauter en changeant le segment code vers l'entr\u00e9e 0x8 de la GDT : jmp 0x8:(trampoline32 - trampoline_start + trampoline_addr)","title":"Le code 16 bits"},{"location":"x86_64/tutoriels/smp/SMP/#le-code-32-bits","text":"On doit dans un premier temps charger la table de page dans le cr3 , puis activer le paging et le PAE du cr4 en activant les bits 5 et 7 du registre cr4 : ; Chargement de la table de page : mov eax, dword [0x600] mov cr3, eax ; Activation du paging et du PAE mov eax, cr4 or eax, 1 << 5 or eax, 1 << 7 mov cr4, eax On active maintenant le mode long, en activant le 8\u00e8me bit de l'EFER ( Extended Feature Enable Register ) : mov ecx, 0xc0000080 ; registre efer rdmsr or eax,1 << 8 wrmsr On active ensuite le paging en \u00e9crivant le 31\u00e8me bit du registre cr0 : mov eax, cr0 or eax, 1 << 31 mov cr0, eax Et pour finir il faut cr\u00e9er puis charger une GDT 64 bits : align 16 gdt_64: dw gdt_64_end - gdt_64_start - 1 dd gdt_64_start - trampoline_start + trampoline_addr align 16 gdt_64_start: ; null selector 0x0 dq 0 ; cs selector 8 dq 0x00AF98000000FFFF ; ds selector 16 dq 0x00CF92000000FFFF gdt_64_end: ; Chargement de la nouvelle GDT lgdt [gdt_64 - trampoline_start + trampoline_addr] On peut ensuite passer \u00e0 la section 64 bits, en utilisant l'instruction jmp comme pr\u00e9c\u00e9dement : ; jmp 0x8 : permet de charger le segment de code de la GDT jmp 0x8:(trampoline64 - trampoline_start + trampoline_addr)","title":"Le code 32 bits"},{"location":"x86_64/tutoriels/smp/SMP/#le-code-64-bits","text":"On commence par d\u00e9finir les valeurs des registre ds , ss et es en fonction de la nouvelle GDT : mov ax, 0x10 mov ds, ax mov es, ax mov ss, ax mov ax, 0x0 mov fs, ax mov gs, ax Et on charge ensuite la GDT, l'IDT et la stack au bon endroit : ; Chargement de la GDT lgdt [0x580] ; Chargement de l'IDT lidt [0x590] ; Chargement de la stack mov rsp, [0x570] mov rbp, 0x0 On doit ensuite passer du code trampoline au code physique \u00e0 ex\u00e9cuter sur ce nouveau CPU. C'est \u00e0 ce moment que on doit activer certains bits de cr4 et cr0 et surtout le SSE ! jmp virtual_code virtual_code: mov rax, cr0 ; Activation du monitoring de multi-processeur et de l'\u00e9mulation btr eax, 2 bts eax, 1 mov cr0, rax Enfin, pour terminer l'initialisation de ce nouveau CPU il faut finir par : mov rax, [0x610] jmp rax","title":"Le code 64 bits"},{"location":"x86_64/tutoriels/smp/SMP/#note-de-fin","text":"Le nouveau CPU est maintenant fonctionnel, mais ce n'est pas encore fini. Il faut mettre en place un syst\u00e8me de lock pour la communication inter-CPU, mettre \u00e0 jour le multitasking pour utiliser ce nouveau CPU, charger une GDT, un IDT et une stack unique...","title":"Note de fin"},{"location":"x86_64/tutoriels/smp/SMP/#ressources","text":"manuel intel osdev","title":"Ressources"},{"location":"x86_64/tutoriels/smp/VERROU/","text":"Verrou le verrou est utilis\u00e9 pour que un processeur acc\u00e8de \u00e0 un code \u00e0 la fois par exemple on peut utiliser un verrou pour un driver ATA, pour \u00e9viter qu'il y ait plusieurs \u00e9critures en m\u00eame temps alors on utilise un verrou au d\u00e9but et on le d\u00e9bloque \u00e0 la fin un \u00e9quivalent serrait : struct verrou ata_verrou = 0; void ata_read(){ verrouiller(&ata_verrou); // [CODE] deverrouiller(&ata_verrou); }; Pr\u00e9r\u00e9quis m\u00eame si le verrou utilise l'instruction lock il peut \u00eatre utiliser m\u00eame si on a qu'un seul processeur. pour comprendre le verrou il faut avoir un minimum de base en assembleur. L'instruction LOCK l'instruction lock est utilis\u00e9 juste avant une autre instruction qui acc\u00e8de / \u00e9crit dans la m\u00e9moire elle permet d'obtenir la possession exclusive de la partie du cache concern\u00e9e le temps que l'instruction s'ex\u00e9cute. Un seul cpu \u00e0 la fois peut \u00e9xecuter l'instruction. exemple de code utilisant le lock :ou lock bts dword [rdi], 0 Verrouillage & D\u00e9verrouillage Code assembleur pour verrouiller on doit impl\u00e9menter une fonction qui v\u00e9rifie le v\u00e9rrou, si il est \u00e0 1, c'est qu'il est verrouill\u00e9 et que l'on doit attendre si il est \u00e0 0, c'est que on peut le d\u00e9verrouiller pour le deverrouiller on doit juste mettre le v\u00e9rou \u00e0 0 pour le verrouillage le code pourrait ressembler \u00e0 ceci : locker: lock bts dword [rdi], 0 jc spin ret spin: pause ; pour gagner des performances test dword [rdi], 0 jnz spin jmp locker ce code test le bit 0 de l'addresse contenu dans le registre rdi (registre utilis\u00e9 pour les arguments de fonctions en 64bit) lock bts dword [rdi], 0 jc spin si le bit est \u00e0 0 il le met \u00e0 1 et CF \u00e0 0 si le bit est \u00e0 1 il met CF \u00e0 1 jc spin jump \u00e0 spin seulement si CF == 1 pour le d\u00e9v\u00e9rouillage le code pourrait ressembler \u00e0 ceci : unlock: lock btr dword [rdi], 0 ret il reset juste le bit contenu dans rdi maintenant on doit rajouter un temps mort parfois si un cpu a crash ou a oubli\u00e9 de d\u00e9verrouiller un verrou il peut arriver que les autres cpu soient bloqu\u00e9s donc il est recommand\u00e9 de rajouter un temps mort pour signaler l'erreur locker: mov rax, 0 lock bts dword [rdi], 0 jc spin ret spin: inc rax cmp rax, 0xfffffff je timed_out pause ; pour gagner des performances test dword [rdi], 0 jnz spin jmp locker timed_out: ; code du time out le temps pris ici est stock\u00e9 dans le registre rax \u00e0 chaque fois il l'incr\u00e9mente et si il est \u00e9gal \u00e0 0xfffffff alors il saute \u00e0 timed_out on peut utiliser une fonction c/c++ dans timed_out Code C dans le code c on peut se permettre de rajouter des informations au verrou, on peut rajouter le fichier, la ligne, le cpu etc... cela permet de mieux d\u00e9bugger si il y a une erreur dans le code les fonction en c doivent \u00eatre utilis\u00e9 comme ceci : void locker(volatile uint32_t* lock); void unlock(volatile uint32_t* lock); si on veut rajouter plus d'information au lock on doit faire une structure contenant un membre 32bit struct verrou{ uint32_t data; // ne doit pas \u00eatre chang\u00e9 const char* fichier; uint64_t line; uint64_t cpu; }__attribute__(packed); maintenant vous devez rajouter des fonction verrouiller et d\u00e9verrouiller qui appellerons locker et unlock note : si vous voulez avoir la ligne/le fichier, vous devez utiliser des #define et non des fonction void verrouiller(verrou* v){ // code pour remplir les donn\u00e9es du v\u00e9rrou locker(&(v->data)); } void deverrouiller(verrou* v){ unlocker(&(v->data)); } maintenant vous devez implementer la fonction qui serra appel\u00e9 dans timed_out void crocheter_le_verrou(verrou* v){ // vous pouvez log des informations importantes ici } maintenant vous pouvez choisir entre 2 possibilit\u00e9 : dans la fonction crocheter_le_verrou vous continuez en attandant jusqu'\u00e0 ce que le v\u00e9rrou soit deverrouill\u00e9 dans la fonction crocheter_le_verrou vous mettez le membre data du v\u00e9rou v \u00e0 0, ce qui forcera le v\u00e9rrou \u00e0 \u00eatre d\u00e9v\u00e9rouiller Utilisation maintenant pour utiliser votre verrou vous pouvez juste faire verrou ata_verrou = {0}; void ata_read(){ verrouiller(&ata_verrou); // votre code ici deverrouiller(&ata_verrou); } et le code serra \u00e9x\u00e9cut\u00e9 seulement \u00e0 1 cpu \u00e0 la fois ! Il est important d'utiliser les verrou quand il le faut, dans un allocateur de frame, le changement de context, l'utilisation d'appareils...","title":"Verrou"},{"location":"x86_64/tutoriels/smp/VERROU/#verrou","text":"le verrou est utilis\u00e9 pour que un processeur acc\u00e8de \u00e0 un code \u00e0 la fois par exemple on peut utiliser un verrou pour un driver ATA, pour \u00e9viter qu'il y ait plusieurs \u00e9critures en m\u00eame temps alors on utilise un verrou au d\u00e9but et on le d\u00e9bloque \u00e0 la fin un \u00e9quivalent serrait : struct verrou ata_verrou = 0; void ata_read(){ verrouiller(&ata_verrou); // [CODE] deverrouiller(&ata_verrou); };","title":"Verrou"},{"location":"x86_64/tutoriels/smp/VERROU/#prerequis","text":"m\u00eame si le verrou utilise l'instruction lock il peut \u00eatre utiliser m\u00eame si on a qu'un seul processeur. pour comprendre le verrou il faut avoir un minimum de base en assembleur.","title":"Pr\u00e9r\u00e9quis"},{"location":"x86_64/tutoriels/smp/VERROU/#linstruction-lock","text":"l'instruction lock est utilis\u00e9 juste avant une autre instruction qui acc\u00e8de / \u00e9crit dans la m\u00e9moire elle permet d'obtenir la possession exclusive de la partie du cache concern\u00e9e le temps que l'instruction s'ex\u00e9cute. Un seul cpu \u00e0 la fois peut \u00e9xecuter l'instruction. exemple de code utilisant le lock :ou lock bts dword [rdi], 0","title":"L'instruction LOCK"},{"location":"x86_64/tutoriels/smp/VERROU/#verrouillage-deverrouillage","text":"","title":"Verrouillage &amp; D\u00e9verrouillage"},{"location":"x86_64/tutoriels/smp/VERROU/#code-assembleur","text":"pour verrouiller on doit impl\u00e9menter une fonction qui v\u00e9rifie le v\u00e9rrou, si il est \u00e0 1, c'est qu'il est verrouill\u00e9 et que l'on doit attendre si il est \u00e0 0, c'est que on peut le d\u00e9verrouiller pour le deverrouiller on doit juste mettre le v\u00e9rou \u00e0 0 pour le verrouillage le code pourrait ressembler \u00e0 ceci : locker: lock bts dword [rdi], 0 jc spin ret spin: pause ; pour gagner des performances test dword [rdi], 0 jnz spin jmp locker ce code test le bit 0 de l'addresse contenu dans le registre rdi (registre utilis\u00e9 pour les arguments de fonctions en 64bit) lock bts dword [rdi], 0 jc spin si le bit est \u00e0 0 il le met \u00e0 1 et CF \u00e0 0 si le bit est \u00e0 1 il met CF \u00e0 1 jc spin jump \u00e0 spin seulement si CF == 1 pour le d\u00e9v\u00e9rouillage le code pourrait ressembler \u00e0 ceci : unlock: lock btr dword [rdi], 0 ret il reset juste le bit contenu dans rdi maintenant on doit rajouter un temps mort parfois si un cpu a crash ou a oubli\u00e9 de d\u00e9verrouiller un verrou il peut arriver que les autres cpu soient bloqu\u00e9s donc il est recommand\u00e9 de rajouter un temps mort pour signaler l'erreur locker: mov rax, 0 lock bts dword [rdi], 0 jc spin ret spin: inc rax cmp rax, 0xfffffff je timed_out pause ; pour gagner des performances test dword [rdi], 0 jnz spin jmp locker timed_out: ; code du time out le temps pris ici est stock\u00e9 dans le registre rax \u00e0 chaque fois il l'incr\u00e9mente et si il est \u00e9gal \u00e0 0xfffffff alors il saute \u00e0 timed_out on peut utiliser une fonction c/c++ dans timed_out","title":"Code assembleur"},{"location":"x86_64/tutoriels/smp/VERROU/#code-c","text":"dans le code c on peut se permettre de rajouter des informations au verrou, on peut rajouter le fichier, la ligne, le cpu etc... cela permet de mieux d\u00e9bugger si il y a une erreur dans le code les fonction en c doivent \u00eatre utilis\u00e9 comme ceci : void locker(volatile uint32_t* lock); void unlock(volatile uint32_t* lock); si on veut rajouter plus d'information au lock on doit faire une structure contenant un membre 32bit struct verrou{ uint32_t data; // ne doit pas \u00eatre chang\u00e9 const char* fichier; uint64_t line; uint64_t cpu; }__attribute__(packed); maintenant vous devez rajouter des fonction verrouiller et d\u00e9verrouiller qui appellerons locker et unlock note : si vous voulez avoir la ligne/le fichier, vous devez utiliser des #define et non des fonction void verrouiller(verrou* v){ // code pour remplir les donn\u00e9es du v\u00e9rrou locker(&(v->data)); } void deverrouiller(verrou* v){ unlocker(&(v->data)); } maintenant vous devez implementer la fonction qui serra appel\u00e9 dans timed_out void crocheter_le_verrou(verrou* v){ // vous pouvez log des informations importantes ici } maintenant vous pouvez choisir entre 2 possibilit\u00e9 : dans la fonction crocheter_le_verrou vous continuez en attandant jusqu'\u00e0 ce que le v\u00e9rrou soit deverrouill\u00e9 dans la fonction crocheter_le_verrou vous mettez le membre data du v\u00e9rou v \u00e0 0, ce qui forcera le v\u00e9rrou \u00e0 \u00eatre d\u00e9v\u00e9rouiller","title":"Code C"},{"location":"x86_64/tutoriels/smp/VERROU/#utilisation","text":"maintenant pour utiliser votre verrou vous pouvez juste faire verrou ata_verrou = {0}; void ata_read(){ verrouiller(&ata_verrou); // votre code ici deverrouiller(&ata_verrou); } et le code serra \u00e9x\u00e9cut\u00e9 seulement \u00e0 1 cpu \u00e0 la fois ! Il est important d'utiliser les verrou quand il le faut, dans un allocateur de frame, le changement de context, l'utilisation d'appareils...","title":"Utilisation"}]}